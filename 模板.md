[toc]

### 随机数rng()

```
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

```



# 基础算法

## 二维前缀和

```cpp
int n, m, q; std::cin >> n >> m >> q;
std::vector<std::vector<int>> s(n + 1, std::vector<int>(m + 1));
for(int i = 1; i <= n; i ++)
    for(int j = 1; j <= m; j ++)
        std::cin >> s[i][j], s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
while(q --)
{
    int x1, x2, y1, y2;
    std::cin >> x1 >> y1 >> x2 >> y2;
    std::cout << s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] << "\n";
}
```

## 二维差分

```cpp
cin >> n >> m >> q; 
for(int i = 1; i <= n; i ++)
    for(int j = 1; j <= m; j ++)
        cin >> a[i][j];
while(cin >> u >> v >> x >> y >> c)
{
    x ++;
    y ++;
    b[u][v] +=c;
    b[x][v] -=c;
    b[u][y] -=c;
    b[x][y] +=c; 
}
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j ++)
        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1], cout << b[i][j] + a[i][j] << " \n"[j == m];
```

## 归并求逆序对

```cpp
auto merge_sort = [&](auto merge_sort, int l, int r) -> LL{
    if(l >= r) return 0;
    int mid = l + r >> 1;
    LL res = merge_sort(merge_sort, l, mid) + merge_sort(merge_sort, mid + 1, r);
    int i = l, j = mid + 1;
    vector<int> t;
    while(i <= mid && j <= r)
    {
        if(v[i] <= v[j])
            t.push_back(v[i ++ ]);
        else
        {
            res += mid - i + 1;
            t.push_back(v[j ++]);
        }

    }
    while(i <= mid)
        t.push_back(v[i ++]);
    while(j <= r)
        t.push_back(v[j ++]);
    i = l;
    for(auto& ite : t)
        v[i ++] = ite;
    return res;
};
LL res = merge_sort(merge_sort, 0, n - 1);
```





## 取模

```cpp
constexpr int P = 1000000007;
typedef long long LL;
// assume -P <= x < 2P
int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, LL b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    Z(LL x) : x(norm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = LL(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        LL v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
```



# 数据结构

## 单调栈

```cpp
int n; cin >> n;
vector<int> v(n);
for(int& x : v) cin >> x;
stack<int> s;
for(int& x : v)
    if(!s.size()) s.push(x), cout << -1 << " ";
else
{
    while(s.size() && s.top() >= x) s.pop();
    if(!s.size()) cout << -1 << " ";
    else
        cout << s.top() << " ";
    s.push(x);
}
```



## 单调队列

```cpp
int n, k; cin >> n >> k;
 b       r<int> a(n);
for(int& x : a)cin >> x;
deque<int> q;
for(int i = 0; i < n; i ++) // find the k size window minv
{
    if(q.size() && i - q.front() >= k) q.pop_front();
    while(q.size() && a[i] <= a[q.back()]) q.pop_back();
    q.push_back(i);
    if(i - k + 1 >= 0)
    {
        cout << a[q.front()] << " ";
    }
}
q.clear`   
cout << "\n";
for(int i = 0; i < n; i ++) // find the k size window maxv
{
    if(q.size() && i - q.front() >= k) q.pop_front();
    while(q.size() && a[i] >= a[q.back()]) q.pop_back();
    q.push_back(i);
    if(i - k + 1 >= 0)
    {
        cout << a[q.front()] << " ";
    }
}
```



## 树状数组

```cpp
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
     
    Fenwick(int n = 0) {
        init(n);
    }
     
    void init(int n) {
        this->n = n;
        a.assign(n, T());
    }
     
    void add(int x, T v) {
        for (int i = x; i <= n; i += i & -i) {
            a[i - 1] += v;
        }
    }
     
    T sum(int x) {
        auto ans = T();
        for (int i = x; i > 0; i -= i & -i) {
            ans += a[i - 1];
        }
        return ans;
    }
     
    T rangeSum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
     
    int kth(T k) {
        int x = 0;
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x; // index from zero
    }
};

```

## 并查集

```cpp
struct DSU {
    std::vector<int> p, siz;
    DSU(int n) : p(n+1), siz(n+1, 1) { std::iota(p.begin(), p.end(), 0); }
    int find(int x) {
        return p[x] == x ? x : p[x] = find(p[x]);
    }
    bool same(int x, int y) { return find(x) == find(y); }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;
        siz[x] += siz[y];
        p[y] = x;
        return true;
    }
    int size(int x) { return siz[find(x)]; }
};
```

## ST表

```cpp
struct RMQ{ // 超时的话记得改写为数组
    int n, m;
    vector<vector<int>> f, g;
    vector<int> q;
    RMQ(int N, int M) : n(N), m(M), f(n + 1, vector<int>(m + 1)), g(n + 1, vector<int>(m + 1)), q(n + 1){}
    
	void init(){
		for(int j = 0; j < m; j ++)
			for(int i = 1; i + (1 << j) <= n + 1; i ++)
			{
				if(!j) f[i][j] = q[i], g[i][j] = q[i];
				else
				{
					f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
					g[i][j] = min(g[i][j - 1], g[i + (1 << j - 1)][j - 1]);
				}
					
			}
	}
	int ask_max(int l, int r){
		int k = log2(r - l + 1);
		return max(f[l][k], f[r - (1 << k) + 1][k]);
	}
	int ask_min(int l, int r){
		int k = log2(r - l + 1);
		return min(g[l][k], g[r - (1 << k) + 1][k]);
	}
};
```
## DFS序 + 子树查询(单点修改 + 区间查询异或和)

```cpp


template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
     
    Fenwick(int n = 0) {
        init(n);
    }s
     
    void init(int n) {
        this->n = n;
        a.assign(n, T());
    }
     
    void add(int x, T v) {
    	assert(x != 0);
        for (int i = x; i <= n; i += i & -i) {
            a[i - 1] ^= v;
        }
    }
     
    T sum(int x) {
        auto ans = T();
       
        for (int i = x; i > 0; i -= i & -i) {
            ans ^= a[i - 1];
        }
        return ans;
    }
     
    T rangeSum(int l, int r) {
        return sum(r) ^ sum(l - 1);
    }
     
    int kth(T k) {
        int x = 0;
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x;
    }
};

 
void solve() {
    int n, q; cin >> n >> q;
    int idx = 0;
    Fenwick<int> sub(n), path(n);    
    vector<vector<int>> g(n + 1);
    vector<int> w(n + 1);
    vector<int> l(n + 1), r(n + 1);
    for(int i = 1; i <= n; i ++) cin >> w[i];
    for(int i = 0; i < n - 1; i ++)
    {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    function<void(int, int)> dfs = [&](int u, int pre){
        l[u] = ++ idx;
        for(auto i : g[u])
            if(i != pre)
                dfs(i, u);
        r[u] = idx;
    };
    dfs(1, 0);
    
   
	for(int i = 1; i <= n; i ++) sub.add(l[i], w[i]);


    while(q --)
    {
        int op, x, y; cin >> op;
        if(op == 1) 
        {
            cin >> x >> y;
            sub.add(l[x], w[x] ^ y);
            w[x] = y;
        }       
        else
        {
            int x; cin >> x;
            int ll = l[x], rr = r[x];
            cout << sub.rangeSum(ll, rr) << "\n";
        }
    }
}
 

```

## 珂朵莉树

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
#define int LL

int qmi(int a, int b, int m){
    int res = 1 % m; a %= m;
    while(b)
    {
        if(b & 1) res = res * a % m;
        b >>= 1;
        a = a * a % m;
    }
    return res;
}


struct Node_t{
    int l, r;
    mutable int v;
    Node_t(const int &il, const int &ir, const int &iv) : l(il), r(ir), v(iv) {}
    bool operator<(const Node_t &w) const { return l < w.l; }
};

struct ODT{
    set<Node_t> odt;
    ODT(){}
    auto split(int x){
        auto it = --odt.upper_bound(Node_t{x, 0, 0});
        if(it != odt.end() && it->l == x)
            return it;
        int l = it->l, r = it->r, v = it->v;
        odt.erase(it);
        odt.insert(Node_t(l, x - 1, v));
        return odt.insert(Node_t(x, r, v)).first;
    }
    void assign(int l, int r, int v) {
        auto itr = split(r + 1), itl = split(l);
        odt.erase(itl, itr);
        odt.insert(Node_t(l, r, v));
    }
    
    void add(int l, int r, int v){
        auto end = split(r + 1);
        for(auto i = split(l); i != end; i ++)
            i->v += v;
    }
    int get_kth_small(int l, int r, int k){
        auto end = split(r + 1);
        vector<array<int, 2>> v;
        for(auto i = split(l); i != end; i ++)
            v.push_back({i->v, i->r - i->l + 1});
        sort(v.begin(), v.end());
        for(auto i : v)
        {
            k -= i[1];
            if(k <= 0)
                return i[0];
        }
        return v.back()[0];
    }
    int sum_of_pow(int l, int r, int x, int y){
        auto end = split(r + 1);
        int res = 0;
        for(auto i = split(l); i != end; i ++)
            res += qmi(i->v, x, y) * (i->r - i->l + 1), res %= y;
        return res;
    }
};

void solve(){
    int n, m, seed, vmax; cin >> n >> m >> seed >> vmax;
    auto rnd = [&]() ->int {
        int ret = seed;
        seed = (seed * 7 + 13) % 1000000007;
        return ret;
    };
    auto ot = ODT();
    for(int i = 1; i <= n; i ++)
    {
        int r = rnd();
        ot.odt.insert(Node_t(i, i, r % vmax + 1)); 
    }
    for(int i = 1; i <= m; i ++)
    {
        int opr = rnd() % 4 + 1, l = rnd() % n + 1, r = rnd() % n + 1, x, y;
        if (l > r)
            swap(l, r);
        if (opr == 3)
            x = rnd() % (r - l + 1) + 1;
        else
            x = rnd() % vmax + 1;
        if (opr == 4)
            y = rnd() % vmax + 1;
        switch (opr)
        {
        case 1:
            ot.add(l, r, x);
            break;
        case 2:
            ot.assign(l, r, x);
            break;
        case 3:
            cout << ot.get_kth_small(l, r, x) << "\n";
            break;
        case 4:
            cout << ot.sum_of_pow(l, r, x, y) << "\n";
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int T;
    T = 1;
    // cin >> T;
    while (T--)
        solve();
    return 0;
}

```

## 笛卡尔树


```cpp
// 区间最小值 -> 左右端点的LCA
template <class T>
struct CartesianTree{
    vector<T> a;
    vector<int> l, r;
    int root, n;
    CartesianTree(int _n) : n(_n), a(_n + 1), l(_n + 1), r(_n + 1) {}
    CartesianTree(vector<T> _a) : n(_a.size() - 1), a(_a), l(_a.size(), 0), r(_a.size(), 0) {this->init();}
    void init(){
        stack<int> st;
        int n = this->a.size();
        for(int i = 1; i <= n; i ++)
        {
            int last = 0;
            while(st.size() && a[st.top()] > a[i])
            {
                last = st.top();
                st.pop();
            }
            if(st.size()) r[st.top()] = i;
            else
                this->root = i;
            l[i] = last;
            st.push(i);
        }
    }
    void print(){
    	for(int i = 1; i <= n; i ++)
    		cout << " i : " << i << " " << " a[i] : " << a[i] << " " << " l[i] : " << l[i] << " r[i] " << r[i] << "\n";
    }
}; 

```

## 线段树

### 线段树二分 

$ask$的作用

找到一个序列中[l, r] 这段中大于等于$d$的第一个数的下标, 不存在输出$-1$

```cpp

#define ls u << 1
#define rs u << 1 | 1
struct SegTree{
    
    struct Node{
        // to do
        
    };
    
    vector<int> w;
    vector<Node> tr;
    SegTree(int n) :tr(n * 4 + 1), w(n + 1){}
    
    void pushup(Node& u, Node& l, Node& r){
        // to do
        
    }
    void pushup(int u){
        pushup(tr[u], tr[ls], tr[rs]);
    }
    void build(int u, int l, int r){
        tr[u] = {l, r};
        if(l == r)
        {
            // to do 
            
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int idx, int val){
        if(tr[u].l == tr[u].r && tr[u].l == idx)
        {
            // to do 
            
            return;
        }
        int mid = tr[u].l + tr[u].r >> 1;
        if(idx <= mid) modify(ls, idx, val);
        else
            modify(rs, idx, val);
        pushup(u);
    }
    
    Node query(int u, int L, int R){
        if(tr[u].l >= L && tr[u].r <= R)
            return tr[u];
        int mid = tr[u].l + tr[u].r >> 1;
        if(R <= mid) return query(ls, L, R);
        else if (L > mid) return query(rs, L, R);
        else
        {
            // to do
        }
    }
    int ask(int u, int L, int R, int d){
        if(tr[u].l == L && tr[u].r == R)
        {
            if(tr[u].maxv < d) return -1;
            if(tr[u].l == tr[u].r) return tr[u].l; 
            int mid = tr[u].l + tr[u].r >> 1;
            if(tr[ls].maxv >= d) return ask(ls, L, mid, d);
            return ask(rs, mid + 1, R, d);
        }
        int mid = tr[u].l + tr[u].r >> 1;
        if(R <= mid) return ask(ls, L, R, d);
        else if(L > mid) return ask(rs, L, R, d);
        else
        {
            int pos = ask(ls, L, mid, d);
            if(pos == -1) return ask(rs, mid + 1, R, d);
            else
                return pos;
        }
    }
};

void solve() {
    int n, q; cin >> n >> q;
    SegTree se(n);
    for(int i = 1; i <= n; i ++) cin >> se.w[i];
    se.build(1, 1, n);
    while(q --)
    {
        int op; cin >> op;
        if(op == 1)
        {
            int x, d; cin >> x >> d;
            se.modify(1, x, d);
        }
        else
        {
            int l, r, d; cin >> l >> r >> d;
            cout << se.ask(1, l, r, d) << "\n";
        }
    }
}
 
```



### 线段树(单点修改)

```cpp
#define ls u << 1
#define rs u << 1 | 1
struct SegTree{
    
    struct Node{
        // to do
    };
    
    vector<int> w;
    vector<Node> tr;
    SegTree(int n) :tr(n * 4 + 1), w(n + 1){}
    
    void pushup(Node& u, Node& l, Node& r){
        // to do
    }
    void pushup(int u){
        pushup(tr[u], tr[ls], tr[rs]);
    }
    void build(int u, int l, int r){
        tr[u] = {l, r};
        if(l == r)
        {
            // to do 
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int idx, int val){
        if(tr[u].l == tr[u].r && tr[u].l == idx)
        {
            // to do 
            return;
        }
        int mid = tr[u].l + tr[u].r >> 1;
        if(idx <= mid) modify(ls, idx, val);
        else
            modify(rs, idx, val);
        pushup(u);
    }
    
    Node query(int u, int L, int R){
        if(tr[u].l >= L && tr[u].r <= R)
            return tr[u];
        int mid = tr[u].l + tr[u].r >> 1;
        if(R <= mid) return query(ls, L, R);
        else if (L > mid) return query(rs, L, R);
        else
        {
            // to do
        }
    }
};
```

### 线段树(区间修改)

```cpp
#define int long long 
#define ls u << 1
#define rs u << 1 | 1
struct SegTree{
    
    struct Node{
        // to do
        
    };
    
    vector<int> w;
    vector<Node> tr;
    SegTree(int n) :tr(n * 4 + 1), w(n + 1){}
    void pushdown(Node& u, Node& l, Node& r){
        // to do
        if(u.add)
        {
            eval(l, add);
            eval(r, add);
            u.add = 0;
        }
    }
    void pushup(Node& u, Node& l, Node& r){
        // to do
        
    }
    void pushup(int u){
        pushup(tr[u], tr[ls], tr[rs]);
    }
    void pushdown(int u){
        pushdown(tr[u], tr[ls], tr[rs]);
    }
    void build(int u, int l, int r){
        tr[u] = {l, r};
        if(l == r)
        {
            // to do 
            
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        pushup(u);
    }
    
    void eval(Node& t, int add, int mul){
        // to do
        // t.sum = (t.sum * mul + (t.r - t.l + 1) * add) % p;
        // t.mul = t.mul * mul % p;
        // t.add = (t.add * mul + add) % p;
    }
    
    void modify(int u, int idx, int val){ // 单点修改
        if(tr[u].l == tr[u].r && tr[u].l == idx)
        {
            // to do 
            
            return;
        }
        int mid = tr[u].l + tr[u].r >> 1;
        if(idx <= mid) modify(ls, idx, val);
        else
            modify(rs, idx, val);
        pushup(u);
    }
    void modify(int u, int L, int R, int val) // 区间修改
    {
        if(tr[u].l >= L && tr[u].r <= R)
        {
            // to do
            // eval(tr[u], val);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(L <= mid) modify(ls, L, R, val);
        if(R > mid) modify(rs, L, R, val);
        pushup(u);
        
    }
    Node query(int u, int L, int R){
        if(tr[u].l >= L && tr[u].r <= R)
            return tr[u];
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(R <= mid) return query(ls, L, R);
        else if (L > mid) return query(rs, L, R);
        else
        {
            // to do
            
        }
    }
   
};
```

# 字符串

## 字典树

### 模板



```cpp
	auto insert = [&](string& str) -> void{
        int p = 0;
        for(auto& ite : str)
        {
            int u = ite - 'a';
            if(!s[p][u]) s[p][u] = ++ idx;
            p = s[p][u];
        }
        cnt[p] ++ ;
    };
    auto query = [&](string& str) -> int{
        int p = 0;
        for(auto& ite : str)
        {
            int u = ite - 'a';
            if(!s[p][u]) return 0;
            p = s[p][u];
        }
        return cnt[p];
    };
```

### 最大异或对

```cpp
int n; cin >> n;
idx = 1;
auto insert = [&](int x){
    int p = 0;
    for(int i = 30; ~i; i --)
    {
        int u = x >> i & 1;
        if(!s[p][u]) s[p][u] = idx ++ ;
        p = s[p][u];
    }
};
auto get_max = [&](int x) -> int{
    int p = 0, res = 0;
    for(int i = 30; ~i; i --)
    {
        int u = x >> i & 1;
        if(s[p][!u])
            res = res << 1 | !u, p = s[p][!u];
        else
            res = res << 1 | u, p = s[p][u];
    }
    return res ^ x;
};
int res = 0;
for(int i = 0; i < n; i ++)
{
    int x; cin >> x;
    insert(x);
    res = max(res, get_max(x));

}
cout << res << "\n";
```



### 能否成为字典序最小

给定$n$个字符串，互不相等，你可以任意指定字符之间的大小关系（即重定义字典序），求有多少个串可能成为字典序最小的串，并输出它们

思路: 字典树 + topsort

```cpp

#include <bits/stdc++.h>
 
typedef long long LL;

using namespace std;
const int N = 300010;
int son[N][30];
int cnt[N], idx;

inline void insert(string & str){
	int p = 0;
	for(auto& ite : str)
	{
		int u = ite - 'a';
		if(!son[p][u]) son[p][u] = ++ idx;
		p = son[p][u];
	}
	cnt[p] ++ ;
}

bool check(string& str){
	int p = 0;
	vector<int> d(26);
	vector<vector<int>> g(26);
	for(auto& ite : str)
	{
		int u = ite - 'a';
		if(cnt[p]) return false; // 已经有某个字符串作为前缀了
		for(int i = 0; i < 26; i ++)
			if(i != u && son[p][i]) d[i] ++ , g[u].push_back(i); // 为 topsort建图
		p = son[p][u];
	}
	queue<int> q;
	for(int i = 0; i < 26; i ++)
		if(!d[i]) q.push(i);
	while(q.size())
	{
		int t = q.front(); q.pop();
		for(auto& val : g[t])
			if(--d[val] == 0) q.push(val);
	}
	return count(d.begin(), d.end(), 0) == 26;
}

void solve() {
    int n; cin >> n;
    vector<string> v(n);
    for(int i = 0; i < n; i ++)
    	cin >> v[i], insert(v[i]);
    vector<string> res;
    for(auto& ite : v)
    	if(check(ite))
    		res.push_back(ite);
    cout << res.size() << "\n";
    for(auto& ite : res)
    	cout << ite << "\n";
}
 
int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T = 1;
    // cin >> T;
    
    while (T--) {
        solve();
    }
    
    return 0;
}

```

## exkmp

```cpp


std::vector<int> zFunction(std::string s) {
    int n = s.size();
    std::vector<int> z(n + 1);
    z[0] = n;
    for (int i = 1, j = 1; i < n; i++) {
        z[i] = std::max(0, std::min(j + z[j] - i, z[i - j]));
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] > j + z[j]) {
            j = i;
        }
    }
    return z;
}


```


## KMP

### KMP求匹配位置

```cpp
struct kizk_kmp{
    string p, s;
    int n, m;
    vector<int> ne, idx;
    kizk_kmp(string& _p) : p(_p){this->n = _p.size();}
    kizk_kmp(string& _p, string& _s) : p(_p), s(_s){this->n = _p.size(), this->m = _s.size();} 
    kizk_kmp(){}
    void set_p(string& a){
        if(a == this->p) return;
        this->p = a, this->n = a.size();
        this->ne.clear();
    }
    void set_s(string& a){
        if(this->s == a) return;
        this->s = a, this->m = a.size(); 
        this->idx.clear();
    }
    vector<int> kmp_ne(){
        if(this->ne.size()) return this->ne;
        int n = this->n;
        string p = this->p;
        vector<int> ne(n + 1);
        for(int i = 1, j = 0; i < n; i ++)
        {
            while(j && p[i] != p[j]) j = ne[j];
            j += (p[i] == p[j]);
            ne[i + 1] = j;
        }
        return this->ne = ne;
    }
    vector<int> kmp_idx(){
        if(!this->ne.size()) this->kmp_ne();
        if(this->idx.size()) return this->idx; 
        int n = this->n, m = this->m;
        string p = this->p, s = this->s;
        vector<int>v;
        for(int i = 0, j = 0; i < m; i ++)
        {
            while(j && s[i] != p[j]) j = ne[j];
            j += (s[i] == p[j]);
            if(j == n)
                v.push_back(i - j + 1), j = ne[j]; 
            // left idx (i - j + 1) from zero  right idx (i) idx from zero
        }
        return this->idx = v;
    }
    vector<int> kmp_idx(string& s){
        if(!this->ne.size()) this->kmp_ne();
        int n = this->n;
        int m = s.size();
        vector<int>v;
        for(int i = 0, j = 0; i < m; i ++)
        {
            while(j && s[i] != p[j]) j = ne[j];
            j += (s[i] == p[j]);
            if(j == n)
                v.push_back(i - j + 1), j = ne[j];
        }
        return v;
    }
    int kmp_cnt(){
        return this->kmp_idx().size();
    }
    int kmp_cnt(string& s){
        return this->kmp_idx(s).size();
    }

};
```

### KMP求最小循环节

```cpp
std::string str; std::cin >> str; str = ' ' + str;
std::vector<int> ne(n + 1);
for(int i = 2, j = 0; i <= n; i ++)
{
    while(j && str[i] != str[j + 1]) j = ne[j];
    j += str[i] == str[j + 1];
    ne[i] = j;
}

for(int i = 2; i <= n; i ++)
{
    int temp = i - ne[i];
    if(i % temp == 0 && ne[i])
        std::cout << i << ' ' << i / temp << "\n";
}	
```

## 后缀数组
```cpp

struct SuffixArray {
    int n;
    std::vector<int> sa, rk, lc;
    SuffixArray(const std::string &s) {
        n = s.length();
        sa.resize(n);
        lc.resize(n); 
        rk.resize(n);
        std::iota(sa.begin(), sa.end(), 0);
        std::sort(sa.begin(), sa.end(), [&](int a, int b) {return s[a] < s[b];});
        rk[sa[0]] = 0;
        for (int i = 1; i < n; ++i)
            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);
        int k = 1;
        std::vector<int> tmp, cnt(n);
        tmp.reserve(n);
        while (rk[sa[n - 1]] < n - 1) {
            tmp.clear();
            for (int i = 0; i < k; ++i)
                tmp.push_back(n - k + i);
            for (auto i : sa)
                if (i >= k)
                    tmp.push_back(i - k);
            std::fill(cnt.begin(), cnt.end(), 0);
            for (int i = 0; i < n; ++i)
                ++cnt[rk[i]];
            for (int i = 1; i < n; ++i)
                cnt[i] += cnt[i - 1];
            for (int i = n - 1; i >= 0; --i)
                sa[--cnt[rk[tmp[i]]]] = tmp[i];
            std::swap(rk, tmp);
            rk[sa[0]] = 0;
            for (int i = 1; i < n; ++i)
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);
            k *= 2;
        }
        for (int i = 0, j = 0; i < n; ++i) {
            if (rk[i] == 0) {
                j = 0;
            } else {
                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; )
                    ++j;
                lc[rk[i]] = j;
            }
        }
    }
};


```


## AC自动机

### 板子

给定$n$个长度不超过$50$的由小写英文字母组成的单词，以及一篇长为$m$的文章。

请问，其中有多少个单词在文章中出现了。

**注意：每个单词不论在文章中出现多少次，仅累计 $1$ 次。**

```cpp

struct node
{
    int fail;
    int ch[27];
    int ans;
};
struct node NIL = {0};
struct trie
{
    vector<node> tr;
    vector<int> in;
    map<int, int> ref;
    int siz = 0;
    void insert(string& s,int x, char offset = 'a')
    {
        if(!tr.size())
            tr.push_back(NIL);
        int place = 0;
        for (char i : s)
        {
            int t = isalpha(i) ? i - offset : 26;
            if (tr[place].ch[t] == 0)
            {
                tr[place].ch[t] = ++siz;
                tr.push_back(NIL);
                in.push_back(0);
            }
            place = tr[place].ch[t];
        }
        ref[x] = place;
    }
    void build()
    {
        queue<int> q;
        for (int i = 0; i < 26;i++)
            if(tr[0].ch[i])
                q.push(tr[0].ch[i]);
        while(!q.empty())
        {
            int tp = q.front();
            q.pop();
            for (int i = 0; i < 26;i++)
                if(tr[tp].ch[i])
                {
                    tr[tr[tp].ch[i]].fail = tr[tr[tp].fail].ch[i];
                    in[tr[tr[tp].fail].ch[i]]++;
                    q.push(tr[tp].ch[i]);
                }
                else
                    tr[tp].ch[i] = tr[tr[tp].fail].ch[i];
        }
    }
    void query(string& t, char offset = 'a')
    {
        int place = 0;
        for (char i : t)
        {
            int t = isalpha(i) ? i - offset : 26;
            place = tr[place].ch[t];
            tr[place].ans++;
        }
    }
    void topo()
    {
        queue<int> q;
        for (int i = 1; i <= siz;i++)
            if(!in[i])
                q.push(i);
        while(!q.empty())
        {
            int tp = q.front();
            q.pop();
            tr[tr[tp].fail].ans += tr[tp].ans;
            in[tr[tp].fail]--;
            if(!in[tr[tp].fail])
                q.push(tr[tp].fail);
        }
    }
};

void test(){
    int n; cin >> n;
	string b = "";
	trie acam;
	string a;
	for(int i = 1; i <= n; i ++)
	    cin >> a, acam.insert(a, i), b += a, b += '#';
	acam.build();
	acam.query(b); acam.topo();
	int res = 0;
	for(int i = 1; i <= n; i ++)
	    res += acam.tr[acam.ref[i]].ans >= 1; 
    cout << res << "\n"; 
}

```

某人读论文，一篇论文是由许多单词组成的。

但他发现一个单词会在论文中出现很多次，现在他想知道每个单词分别在论文中出现多少次。

```cpp
#include <bits/stdc++.h>

using namespace std;
struct node 
{
    int fail;
    int ch[27]; // 开大一个
    int ans;
};
.... // 这边都是一样的
void solve(){
    int n;
    string b = "";
    cin >> n;
    vector<string> a(n + 1);
    for(int i = 1; i <= n; i ++)
        cin >> a[i];
    trie tr;
    for (int i = 1; i <= n;i++)
    {
        tr.insert(a[i], i);
        b += a[i] + char('z' + 1); // 分隔一下
    }
    tr.build();
    tr.query(b);
    tr.topo();
    int res = 0;
    for (int i = 1; i <= n;i++)
        cout << tr.tr[tr.ref[i]].ans << "\n";;
}
int main()
{
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int T = 1;
    while(T --) solve();
    return 0;
}
```



## border树

### 性质

1. 每个前缀$prefix[i]$的所有$Border$:节点$i$到根的链
2. 哪些前缀有长度为$x$的$Border$: $x$的子树
3. 求两个前缀的公共$Border$等价于求$LCA$

### 求至少出现K次

给一个长度为$n$的仅包含小写字母的字符串$S$，一个正整数$k$，求一个最长的字符串$T$，满足: 
1\. $T$为$S$的前缀 
2\. $T$为$S$的后缀 
3\. $T$在$S$中至少出现$k$次

```cpp
int n, k; cin >> n >> k;
string str; cin >> str;
str = ' ' + str;
vector<int> ne(n + 1);
for(int i = 2, j = 0; i <= n; i ++)
{
    while(j && str[j + 1] != str[i]) j = ne[j];
    if(str[j + 1] == str[i]) j ++ ;
    ne[i] = j;
}
vector<int> cnt(n + 1);
for(int i = n; i >= 1; i --)
    cnt[ne[i]] += ++ cnt[i];
vector<int> ans;
ans.push_back(n);
int kk = ne[n];
while(kk) 
{
    ans.push_back(kk);
    kk = ne[kk];
    if(!kk) break;
}
for(auto& ite : ans)
{
    int i = ite;
    if(cnt[i] >= k)
    {
        cout << str.substr(1, i) << "\n";
        return 0;
    }
}
cout << -1 << "\n";
```

## 字符串哈希

### 单哈希(ULL)

```cpp
const int p = 13331;
typedef unsigned long long ULL;
 
void solve() {
    int n, m; cin >> n >> m;
    string str; cin >> str;
    str = " " + str;
    vector<ULL> c(n + 1), h(n + 1);
    c[0] = 1;
    for(int i = 1; i <= n; i ++)
    {
    	h[i] = h[i - 1] * p + str[i];
    	c[i] = c[i - 1] * p;
    }
    auto get = [&](int l, int r) -> int{
    	return h[r] - h[l - 1] * c[r - l + 1];
    };
    for(int i = 0; i < m; i ++)
    {
    	int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;
    	cout << (get(l1, r1) == get(l2, r2) ? "Yes\n" : "No\n");
    }
}

```

### 单哈希(LL)

```cpp
const int mod = 1e9 + 7, p = 13331;
 
void solve() {
    int n, m; cin >> n >> m;
    string str; cin >> str;
    str = " " + str;
    vector<LL> c(n + 1), h(n + 1);
    c[0] = 1;
    for(int i = 1; i <= n; i ++)
    {
    	h[i] = (h[i - 1] * p % mod + str[i] - 'a' + 1) % mod;
    	c[i] = c[i - 1] * p % mod;
    }
    auto get = [&](int l, int r) -> int{
    	return (h[r] - h[l - 1] * c[r - l + 1] % mod + mod) % mod;
    };
    for(int i = 0; i < m; i ++)
    {
    	int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;
    	cout << (get(l1, r1) == get(l2, r2) ? "Yes\n" : "No\n");
    }
}
```





### 双哈希

```cpp
const int p1 = 13331, p2 = 1333331;
typedef unsigned long long ULL;
 
void solve() {
    int n, m; cin >> n >> m;
    string str; cin >> str;
    str = " " + str;
    vector<ULL> c1(n + 1), c2(n + 1), h1(n + 1), h2(n + 1);
    c1[0] = c2[0] = 1;
    for(int i = 1; i <= n; i ++)
    {
    	h1[i] = h1[i - 1] * p1 + str[i];
    	c1[i] = c1[i - 1] * p1;
    	h2[i] = h2[i - 1] * p2 + str[i];
    	c2[i] = c2[i - 1] * p2;
    }
    auto get = [&](int l, int r) -> pair<ULL, ULL>{
    	return {h1[r] - h1[l - 1] * c1[r - l + 1], h2[r] - h2[l - 1] * c2[r - l + 1]};
    };
    for(int i = 0; i < m; i ++)
    {
    	int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;
    	cout << (get(l1, r1) == get(l2, r2) ? "Yes\n" : "No\n");
    }
}
```



### 线段树版本

```cpp

#include <bits/stdc++.h>
 
typedef long long LL;

using namespace std;

#define ls u << 1
#define rs u << 1 | 1
typedef unsigned long long ULL;
struct SegTree{
    
    struct Node{
        int l, r;
        ULL val;
    };
    const int mod = 1e9 + 7, p = 13331;
    vector<int> w;
    vector<Node> tr;
    vector<ULL> base;
    string str;
    SegTree(int n, string str) :tr(n * 4 + 1), w(n + 1), base(n + 1)
    {
    	this->str = str;
    	base[0] = 1;
    	for(int i = 1; i <= n; i ++)
    	{
    		base[i] = base[i - 1] * p;
    	}
    }
    void pushup(Node& u, Node& l, Node& r){
    	u.val = l.val * base[r.r - r.l + 1] + r.val;
    }
    void build(int u, int l, int r){
        tr[u] = {l, r};
        if(l == r)
        {
            tr[u] = {l, r, str[l] - 'A' + 1};
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        pushup(tr[u], tr[ls], tr[rs]);
    }
    
    ULL query(int u, int L, int R){
        if(tr[u].l >= L && tr[u].r <= R)
            return tr[u].val;
        int mid = tr[u].l + tr[u].r >> 1;
        if(R <= mid) return query(ls, L, R);
        else if(L > mid) return query(rs, L, R) ;
        else
        {
        	 int len = R - mid;	
             return query(ls, L, mid) * base[len] + query(rs, mid + 1, R);
        }
       
    }
};
 

void solve() {
	int n, q; cin >> n >> q;
	string str; cin >> str;
	str = ' ' + str;
	SegTree t(n, str);
	t.build(1, 1, n);
	while(q --)
	{
		int a, b, c, d; cin >> a >> b >> c >> d;
		if(t.query(1, a, b) == t.query(1, c, d))
			cout << "Yes\n";
		else	
			cout << "No\n";
	}
	
}
 
int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T = 1;
    // cin >> T;
    
    while (T--) {
        solve();
    }
    
    return 0;
}

```

## manacher

```cpp
vector<int> manacher(string a) // 最长回文子串为*max_element(hw.begin(), hw.end()) - 1;
{
    string b = "$|";
    for (auto i : a)
    {
        b += i;
        b += '|';
    }
    int len = b.length();
    vector<int> hw(b.length());
    int maxright = 1, mid = 1;
    for (int i = 1; i < len; i++)
    {
        if (i < maxright)
            hw[i] = min(hw[mid * 2 - i], hw[mid] + mid - i);
        else
            hw[i] = 1;
        while (b[i - hw[i]] == b[i + hw[i]])
            hw[i]++;
        if (i + hw[i] > maxright)
        {
            maxright = i + hw[i];
            mid = i;
        }
    }
    return hw;
}
```

## 最小表示法

```cpp
auto minimalRepresentation = [&](string& s) -> string{
        int n = s.size();
        int i = 0, j = 1, k = 0; 
        while(i < n && j < n && k < n)
        {
            char a = s[(i + k) % n], b = s[(j + k) % n];
            if(a == b) k ++ ;
            else
            {
                if(a > b) i += k + 1;
                else j += k + 1;
                if(i == j) i ++ ;
                k = 0;
            }
        }
        i = min(i, j);
        return s.substr(i) + s.substr(0, i);
    };
```



# 图论

## 树上问题

### 树的直径

```cpp
// DFS 
int n; cin >> n;
vector<vector<array<int, 2>>> g(n);
for(int i = 1, a, b, c; i < n; i ++)
cin >> a >> b >> c, g[--a].push_back({--b, c}), g[b].push_back({a, c});
int r = -1, maxv = 0;
auto dfs = [&](auto _, int u, int pre, int dist) -> void{
	if(dist > maxv) r = u, maxv = dist;
	for(auto& [i, w] : g[u])
		if(i ^ pre)
			_(_, i, u, dist + w);
};
dfs(dfs, 0, -1, 0);
dfs(dfs, r, -1, 0);

// DP 两个数组记录
int n; cin >> n;
vector<vector<array<int, 2>>> g(n + 1);
vector<int> d1(n + 1), d2(n + 1);
for(int i = 1, a, b, c; i < n; i ++)
cin >> a >> b >> c, g[a].push_back({b, c}), g[b].push_back({a, c});
int d = 0;
auto dfs = [&](auto _, int u, int pre) -> void{
	for(auto& [i, w] : g[u])
		if(i ^ pre)
		{
			_(_, i, u);
			int t = d1[i] + w;
			if(t > d1[u])
				d2[u] = d1[u], d1[u] = t;
			else if(t > d2[u])
				d2[u] = t;
		}
	d = max(d, d1[u] + d2[u]);
};
dfs(dfs, 1, -1);

// DP 一个数组记录
auto dp = [&](auto _, int u, int fa) -> void{
	for(auto& i : g[u])
		if(i != fa)
		{
			_(_, i, u);
			// w -> 边权
			d = max(d, d1[u] + d1[i] + w);
			d1[u] = max(d1[u], d1[i] + w);
		}
};
dp(dp, 0, -1);

```



## 简单算法

### bellman-ford

```cpp
int n, m, k; cin >> n >> m >> k;
	vector<tuple<int, int, int>> v(m);
	for(int i = 0; i < m; i ++)
	{
		int a, b, c; cin >> a >> b >> c;
		v[i] = tuple<int, int, int>(a, b, c);
	}
	vector<int> d(n + 1, 1e9 + 10);
	d[1] = 0;
	while(k --)
	{
		vector<int> back = d;
		for(auto& ite : v)
		{
			int a = get<0>(ite), b = get<1>(ite), c = get<2>(ite);
			d[b] = min(d[b], back[a] + c);
		}
	}
	if(d[n] > 1e7) cout << "impossible\n";
	else
		cout << d[n] << "\n";
```

### 二分图(匈牙利)

```cpp
// check
#include <bits/stdc++.h>

using namespace std;

int main(){
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int n, m; cin >> n >> m;
    vector<vector<int>> g(n + 1);
    for(int a, b; cin >> a >> b; ) g[a].push_back(b), g[b].push_back(a);
    vector<int> color(n + 1, 0);
    auto dfs = [&](auto dfs, int u, int c) -> bool{
        color[u] = c;
        for(auto& ite : g[u])
        {
            if(!color[ite]) if(!dfs(dfs, ite, 3 - c)) return false;
            if(color[ite] == c)
                return false;
        }
        return true;
    };
    for(int i = 1; i <= n; i ++)
        if(!color[i])
        {
            if(!dfs(dfs, i, 1))
            {
                cout << "No\n";
                return 0;
            }
        }
    cout << "Yes\n";
}


// 最大匹配
#include <bits/stdc++.h>

using namespace std;

int main(){
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int n1, n2, m; cin >> n1 >> n2 >> m;
    vector<vector<int>> g(n1 + 1);
    for(int a, b; cin >> a >> b; ) g[a].push_back(b);
    int res = 0;
    vector<bool> st(n2 + 1, false);
    vector<int> ma(n2 + 1, 0);
    auto find = [&](auto find, int u) -> bool{
        for(auto& ite : g[u])
            if(!st[ite])
            {
                st[ite] = true;
                if(!ma[ite] || find(find, ma[ite]))
                {
                    ma[ite] = u;
                    return true;
                }
            }
        return false;
    };
    for(int i = 1; i <= n1; i ++)
    {
        st = vector<bool>(n2 + 1, false);
        if(find(find, i))
            res ++ ;
    }
    cout << res << "\n";
    return 0;
}
```

### dijkstra

```cpp
auto dijkstra = [&](int root) -> int{
        vector<int> d(n + 1, 1e9 + 10);
        vector<bool> st(n + 1, false);
        d[1] = 0;
        for(int i = 1; i < n; i ++)
        {
            int t = -1;
            for(int j = 1; j <= n; j ++)
                if(!st[j] && (t == -1 || d[j] < d[t]))
                    t = j;
            for(int j = 1; j <= n; j ++)
                d[j] = min(d[j], d[t] + g[t][j]);
            st[t] = true;
        }
        return d[n] == 1e9 + 10 ? -1 : d[n];
    };
   
   
  auto dijkstra = [&](int root) -> int{
        vector<int> d(n + 1, 1e9 + 10);
        d[root] = 0;	
        priority_queue<PII, vector<PII>, greater<PII> > q;
        q.push({0, root});
        while(q.size())
        {
            auto [dist, id] = q.top(); q.pop();
            if(d[id] != dist) continue;
            for(auto& [b, w] : g[id])
            {
                if(d[b] > dist + w)
                {
                    d[b] = dist + w;
                    q.push({d[b], b});
                }
            }
        }
        return d[n] == 1e9 + 10 ? -1 : d[n];
    };
   
```

### Floyd

```cpp
 for(int i = 1; i <= n; i ++) g[i][i] = 0;
    for(int k = 1; k <= n; k ++)
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= n; j ++)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
```

### kruskal

```cpp
int n, m; cin >> n >> m;
    vector<array<int, 3>> v;
    for(int a, b, c; cin >> a >> b >> c; )v.push_back({a, b, c});
    vector<int> p(n + 1);
    iota(p.begin(), p.end(), 0);
    auto find = [&](auto find, int x) -> int{
        return p[x] ^ x ? p[x] = find(find, p[x]) : x;
    };
    sort(v.begin(), v.end(), [&](array<int, 3>& a, array<int, 3>& b){
        return a[2] < b[2];
    });
    int res = 0;
    int cnt = n;
    for(auto&[a, b, c] : v)
    {
        a = find(find, a), b = find(find, b);
        if(a ^ b)
        {
            p[a] = b;
            res += c;
            cnt -- ;
        }
    }
    if(cnt ^ 1)
        cout << "impossible\n";
    else
        cout << res << "\n";
        
```

### prime

```cpp
auto prime = [&]() -> void{
        int res = 0;
        bool flg = true;
        vector<int> d(n + 1, 1e9 + 10);
        vector<bool> st(n + 1, false);
        d[1] = 0;
        for(int i = 0; i < n; i ++)
        {
            int t = -1;
            for(int j = 1; j <= n; j ++)
                if(!st[j] && (t == -1 or d[j] < d[t]))
                    t = j;
            if(i && d[t] == 1e9 + 10)
            {
                flg = false;
                break;
            }
            if(i)
                res += d[t];
            for(int j = 1; j <= n; j ++)
                d[j] = min(d[j], g[t][j]);
            st[t] = true;
        }
        if(flg)
            cout << res << '\n';
        else
            cout << "impossible\n";
    };
    
```

### spfa

```cpp
// 判断负环
auto spfa = [&](int root) -> bool{
        memset(d, 0x3f, sizeof d);
        d[1] = 0;
        queue<int> q;
        for(int i = 1; i <= n; i ++)
            st[i] = true, q.push(i);
        while(q.size())
        {
            int t = q.front();
            q.pop();
            st[t] = false;
            for(auto& [j, w] : g[t])
            {
                if(d[j] > d[t] + w) 
                {
                    d[j] = d[t] + w;
                    cnt[j] = cnt[t] + 1;
                    if(cnt[j] == n)
                        return true;
                    if(!st[j])
                    {
                        st[j] =  true;
                        q.push(j);
                    }
                }
            }
        }
        return false;
    };
    if(spfa(1))
        cout << "Yes\n";
    else
        cout << "No\n";
        
// 
auto spfa = [&](int root) -> void{
        vector<bool> st(n + 1, false);
        vector<int> d(n + 1, 1e9 + 10);
        d[root] = 0;
        queue<int> q;
        q.push(root);
        while(q.size())
        {
            int t = q.front(); q.pop();
            st[t] = false;
            for(auto& [b, w] : g[t])
            {
                if(d[b] > d[t] + w)
                {
                    d[b] = d[t] + w;
                    if(!st[b])
                        st[b] = true, q.push(b);
                }
                    
            }
        }
        if(d[n] > 1e7 + 10) cout << "impossible\n";
        else
            cout << d[n] << "\n";
    };
```



## LCA

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    int n, k; cin >> n >> k;
    int m = __lg(n << 2);
    vector<int> d(n + 1, -1);
    vector<int> dist(n + 1, 1e9);
    vector<vector<array<int, 2>>> g(n + 1);
    vector<vector<int>> fa(n + 1, vector<int>(m + 1));
    for(int i = 0; i < n - 1; i ++)
    {
        int a, b, c; cin >> a >> b >> c;
        g[a].push_back({b, c});
        g[b].push_back({a, c});
    }
    queue<int> q;
    q.push(1);
    d[0] = 0, d[1] = 1;
    dist[1] = 0;
    while(q.size())
    {
        int t = q.front(); q.pop();
        for(auto& ite : g[t])
        {
            int id = ite[0], w = ite[1];
            if(d[id] == -1)
            {
                d[id] = d[t] + 1; 
                dist[id] = dist[t] + w;
                q.push(id);
                fa[id][0] = t;
                for(int i = 1; i <= m; i ++)
                    fa[id][i] = fa[fa[id][i - 1]][i - 1];
            }
        }
    }
    auto get_lca = [&](int x, int y) -> int{
        if(d[x] < d[y]) swap(x, y);
        for(int i = m; i >= 0; i --)
            if(d[fa[x][i]] >= d[y])
                x = fa[x][i];
        if(x == y)
            return x;
        for(int i = m; i >= 0; i --)
            if(fa[x][i] != fa[y][i])
                x = fa[x][i], y = fa[y][i]; 
        return fa[x][0];
    };
    while(k --)
    {
        int a, b; cin >> a >> b;
        int c = get_lca(a, b);
        cout << dist[a] + dist[b] - 2 * dist[c] << "\n";
    }
}
```

## 2-SAT

```cpp
struct TwoSat {
    int n;
    std::vector<std::vector<int>> e;
    std::vector<bool> ans;
    TwoSat(int n) : n(n), e(2 * n), ans(n) {}
    void addClause(int u, bool f, int v, bool g) {
        e[2 * u + !f].push_back(2 * v + g);
        e[2 * v + !g].push_back(2 * u + f);
    }
    bool satisfiable() {
        std::vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);
        std::vector<int> stk;
        int now = 0, cnt = 0;
        std::function<void(int)> tarjan = [&](int u) {
            stk.push_back(u);
            dfn[u] = low[u] = now++;
            for (auto v : e[u]) {
                if (dfn[v] == -1) {
                    tarjan(v);
                    low[u] = std::min(low[u], low[v]);
                } else if (id[v] == -1) {
                    low[u] = std::min(low[u], dfn[v]);
                }
            }
            if (dfn[u] == low[u]) {
                int v;
                do {
                    v = stk.back();
                    stk.pop_back();
                    id[v] = cnt;
                } while (v != u);
                ++cnt;
            }
        };
        for (int i = 0; i < 2 * n; ++i) if (dfn[i] == -1) tarjan(i);
        for (int i = 0; i < n; ++i) {
            if (id[2 * i] == id[2 * i + 1]) return false;
            ans[i] = id[2 * i] > id[2 * i + 1];
        }
        return true;
    }
    std::vector<bool> answer() { return ans; }
};


```

## 最大流

```cpp
constexpr int inf = 1E9;
template<class T>
struct MaxFlow {
    struct _Edge {
        int to;
        T cap;
        _Edge(int to, T cap) : to(to), cap(cap) {}
    };
     
    int n;
    std::vector<_Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<int> cur, h;
     
    MaxFlow() {}
    MaxFlow(int n) {
        init(n);
    }
     
    void init(int n) {
        this->n = n;
        e.clear();
        g.assign(n, {});
        cur.resize(n);
        h.resize(n);
    }
     
    bool bfs(int s, int t) {
        h.assign(n, -1);
        std::queue<int> que;
        h[s] = 0;
        que.push(s);
        while (!que.empty()) {
            const int u = que.front();
            que.pop();
            for (int i : g[u]) {
                auto [v, c] = e[i];
                if (c > 0 && h[v] == -1) {
                    h[v] = h[u] + 1;
                    if (v == t) {
                        return true;
                    }
                    que.push(v);
                }
            }
        }
        return false;
    }
     
    T dfs(int u, int t, T f) {
        if (u == t) {
            return f;
        }
        auto r = f;
        for (int &i = cur[u]; i < int(g[u].size()); ++i) {
            const int j = g[u][i];
            auto [v, c] = e[j];
            if (c > 0 && h[v] == h[u] + 1) {
                auto a = dfs(v, t, std::min(r, c));
                e[j].cap -= a;
                e[j ^ 1].cap += a;
                r -= a;
                if (r == 0) {
                    return f;
                }
            }
        }
        return f - r;
    }
    void addEdge(int u, int v, T c) {
        g[u].push_back(e.size());
        e.emplace_back(v, c);
        g[v].push_back(e.size());
        e.emplace_back(u, 0);
    }
    T flow(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n, 0);
            ans += dfs(s, t, std::numeric_limits<T>::max());
        }
        return ans;
    }
     
    std::vector<bool> minCut() {
        std::vector<bool> c(n);
        for (int i = 0; i < n; i++) {
            c[i] = (h[i] != -1);
        }
        return c;
    }
     
    struct Edge {
        int from;
        int to;
        T cap;
        T flow;
    };
    std::vector<Edge> edges() {
        std::vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2) {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }
};


```

## 费用流

```cpp
struct MCFGraph {
    struct Edge {
        int v, c, f;
        Edge(int v, int c, int f) : v(v), c(c), f(f) {}
    };
    const int n;
    std::vector<Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<i64> h, dis;
    std::vector<int> pre;
    bool dijkstra(int s, int t) {
        dis.assign(n, std::numeric_limits<i64>::max());
        pre.assign(n, -1);
        std::priority_queue<std::pair<i64, int>, std::vector<std::pair<i64, int>>, std::greater<std::pair<i64, int>>> que;
        dis[s] = 0;
        que.emplace(0, s);
        while (!que.empty()) {
            i64 d = que.top().first;
            int u = que.top().second;
            que.pop();
            if (dis[u] < d) continue;
            for (int i : g[u]) {
                int v = e[i].v;
                int c = e[i].c;
                int f = e[i].f;
                if (c > 0 && dis[v] > d + h[u] - h[v] + f) {
                    dis[v] = d + h[u] - h[v] + f;
                    pre[v] = i;
                    que.emplace(dis[v], v);
                }
            }
        }
        return dis[t] != std::numeric_limits<i64>::max();
    }
    MCFGraph(int n) : n(n), g(n) {}
    void addEdge(int u, int v, int c, int f) {
        if (f < 0) {
            g[u].push_back(e.size());
            e.emplace_back(v, 0, f);
            g[v].push_back(e.size());
            e.emplace_back(u, c, -f);
        } else {
            g[u].push_back(e.size());
            e.emplace_back(v, c, f);
            g[v].push_back(e.size());
            e.emplace_back(u, 0, -f);
        }
    }
    std::pair<int, i64> flow(int s, int t) {
        int flow = 0;
        i64 cost = 0;
        h.assign(n, 0);
        while (dijkstra(s, t)) {
            for (int i = 0; i < n; ++i) h[i] += dis[i];
            int aug = std::numeric_limits<int>::max();
            for (int i = t; i != s; i = e[pre[i] ^ 1].v) aug = std::min(aug, e[pre[i]].c);
            for (int i = t; i != s; i = e[pre[i] ^ 1].v) {
                e[pre[i]].c -= aug;
                e[pre[i] ^ 1].c += aug;
            }
            flow += aug;
            cost += i64(aug) * h[t];
        }
        return std::make_pair(flow, cost);
    }
};


```


# 



# 动态规划



## 数位DP(py)

如果一个正整数每一个数位都是 **互不相同** 的，我们称它是 **特殊整数** 。

给你一个 **正** 整数 $n$ ，请你返回区间 $[1, n]$之间特殊整数的数目。

```python
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        s = str(n)
        @lru_cache(None)
        def dfs(i: int, mask: int, is_limit: bool, is_number: bool) -> int:
            if i == len(s): # 到达最后一个数 判断一下之前是否填了数
                return int(is_number)
            res = 0
            if not is_number: # 如果上一个数没填 那我们该数也已不填
                res = dfs(i + 1,mask, False, False)
            up = int(s[i]) if is_limit else 9 # 上界
            for d in range(1 - int(is_number), up + 1):
                if mask >> d & 1 == 0:
                    res += dfs(i + 1, mask|(1 << d), is_limit and d == up, True)
            return res
        return dfs(0, 0, True, False)
```


# 数学



## 数论

### 筛质数 && 求质因子 && 快速幂	

```cpp
LL mul(LL a, LL b, LL m) {
    return static_cast<__int128>(a) * b % m;
}
LL power(LL a, LL b, LL m) {
    LL res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m))
        if (b & 1)
            res = mul(res, a, m);
    return res;
}
bool isprime(LL n) {
    if (n < 2)
        return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    int s = __builtin_ctzll(n - 1);
    LL d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n)
            return true;
        LL x = power(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool ok = false;
        for (int i = 0; i < s - 1; ++i) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok)
            return false;
    }
    return true;
}
std::vector<LL> factorize(LL n) {
    std::vector<LL> p;
    std::function<void(LL)> f = [&](LL n) {
        if (n <= 10000) {
            for (int i = 2; i * i <= n; ++i)
                for (; n % i == 0; n /= i)
                    p.push_back(i);
            if (n > 1)
                p.push_back(n);
            return;
        }
        if (isprime(n)) {
            p.push_back(n);
            return;
        }
        auto g = [&](LL x) {
            return (mul(x, x, n) + 1) % n;
        };
        LL x0 = 2;
        while (true) {
            LL x = x0;
            LL y = x0;
            LL d = 1;
            LL power = 1, lam = 0;
            LL v = 1;
            while (d == 1) {
                y = g(y);
                ++lam;
                v = mul(v, std::abs(x - y), n);
                if (lam % 127 == 0) {
                    d = std::gcd(v, n);
                    v = 1;
                }
                if (power == lam) {
                    x = y;
                    power *= 2;
                    lam = 0;
                    d = std::gcd(v, n);
                    v = 1;
                }
            }
            if (d != n) {
                f(d);
                f(n / d);
                return;
            }
            ++x0;
        }
    };
    f(n);
    std::sort(p.begin(), p.end());
    return p;
}
```



### EXGCD

```cpp
LL exgcd(LL a, LL b, LL& x, LL& y) {
    if(!b)
        return (x = 1, y = 0, a); 
    LL d = exgcd(b, a % b, y, x);
    return (y -= x * (a / b), d);
}
```

### EXCTR

```cpp
// find x
void solve() {
    int n; cin >> n;
    int a = 0, b = 1; // x mod b = a
    auto merge = [&](int& a, int& b, int c, int d) -> void{
        if(a == -1 || b == -1)
            return;
        LL x, y;
        LL g = exgcd(b, d, x, y);
        if((c - a) % g != 0)
        {
            a = b = -1;
            return;
        }
        d /= g; // d'
        LL t = (c - a) / g % d;
        LL t0 = x * t % d;
        if(t0 < 0) t0 += d;
        a = a + b * t0;
        b = b * d;
    };
    for(int i = 0; i < n; i ++)
    {
        int c, d; cin >> d >> c;
        merge(a, b, c, d); 
        if(a == -1 && b == -1)
        {
            cout << "-1\n";
            return;
        }
    }    
    cout << a << "\n";
}
// check x is exist
bool solve() {
    int n; cin >> n;
    map<int, vector<pair<int, int>>> mp;
    for(int i = 0; i < n; i ++)
    {
        int x, a; cin >> x >> a;
        for(int j = 2; j <= x / j; j ++)
        {
            if(x % j == 0)
            {
                int p = j, q = j;
                while(x % j == 0) x /= j, q *= j;
                
                mp[p].push_back({q, a % q});
            }
        }
        if(x > 1) mp[x].push_back({x, a % x});
    }
    for(auto& ite : mp)
    {
        auto v = ite.second;
        int t = max_element(v.begin(), v.end()) -> second;
        for(auto& val : v)
            if(t % val.first != val.second) return false;
    } 
    return true;
}
```

### 求逆元

```cpp
// 快速幂
LL qmi = [&](LL a, LL b, LL p) -> LL{
    LL t = 1;
    while(b){
        if(b & 1) t = t * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return t;
};
// exgcd
LL exgcd(LL a, LL b, LL&x, LL& y){
    if(!b)
        return (x = 1, y = 0, a); 
    LL d = exgcd(b, a % b, y, x);
    return (y -= x * (a / b), d);
}
void solve(){
	LL a, b; cin >> a >> b;
    LL x, y;
    LL d = exgcd(a, b, x, y);
    if(d != 1)
    	cout << "impossible\n";
    else
    	cout << (x % b + b) % b << "\n";
}
// 递推
vector<int> inv(n + 1);
inv[1] = 1;
int p;
for(int i = 2; i <= n; i ++) inv[i] = (p - p / i) * inv[p % i] % p; 
```

### 欧拉函数

欧拉函数是积性函数: $\phi(ab) = \phi(a)\phi(b)$

$if \to n \% 2 == 1:$ $\phi(2n) = \phi(n)$

$n = \sum_{d | n}\phi(d)$



```cpp
// 1 ~ n 欧拉函数的和
void get(int n){
    phi[1] = 1;
    for(int i = 2; i <= n; i ++)
    {
        if(!st[i])
        {
            primes[cnt ++ ] = i;
            phi[i] = i - 1;
        }
        for(int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0)
            {
                phi[primes[j] * i] = phi[i] * primes[j];
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
}
// phi(x)
int x; cin >> x;
        int res = x;
        for(int i = 2; i <= x / i; i ++)
            if(x % i == 0)
            {
                res = res / i * (i - 1);
                while(x % i == 0)
                    x /= i;
            }
        if(x > 1)
            res = res / x * (x - 1);
        cout << res << endl;
```

### 线性同余方程

```cpp
// ax = b(mod m)
// ax - my = b;
LL exgcd(LL a, LL b, LL&x, LL& y){
	if(!b)
	{
		x = 1, y = 0;
		return a;
	}
	LL d = exgcd(b, a % b, y, x);
	y -= x * (a / b);
	return d;
}
 
void solve() {
    LL a, b, m; cin >> a >> b >> m;
    LL x, y;
    LL d = exgcd(a, m, x, y);
    if(b % d != 0)
    {
    	cout << "impossible\n";
    	return;
    }
    LL t = b / d;
    cout << x * t % m << "\n";
}
```

### 数论分块

计算 $\sum\limits_{i = 1}^{n}i$ ${\rm m od}$ $k$ = $n * k - \sum\limits_{i=1}^{n}\lfloor \frac{k}{i} \rfloor *i $

对于每一个 $i$的 的右边界$j$为 $\Large \lfloor \frac{k}{\frac{k}{i} } \rfloor$

```cpp
void solve() {

    int n, k; cin >> n >> k;
    LL res = n * k;
    LL ans = 0;
    for(int l = 1, r; l <= n; l = r + 1)
    {
        r = k / l ? min(n, k / (k / l)) : n;
        ans += (r - l + 1) * (l + r) * (k / l) / 2;
    }
    cout << res - ans << "\n";
}
```

 ### 组合数

```cpp
LL fpow(LL x,LL r)
{
   LL result = 1;
    while (r)
    {
        if (r & 1)result = result * x % mod;
        r >>= 1;
        x = x * x % mod;
    }
    return result;
}
namespace binom {
   LL fac[N], ifac[N];
    int __ = []
    {
        fac[0] = 1;
        for (int i = 1; i <= N - 5; i++)
            fac[i] = fac[i - 1] * i % mod;
        ifac[N - 5] = fpow(fac[N - 5], mod - 2);
        for (int i = N - 5; i; i--)
            ifac[i - 1] = ifac[i] * i % mod;
        return 0;
    }();

    inline LL C(int n, int m)
    {
        if (n < m || m < 0)return 0;
        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
    }

    inline LL A(int n, int m)
    {
        if (n < m || m < 0)return 0;
        return fac[n] * ifac[n - m] % mod;
    }
}
using namespace binom;
```
### 类欧几里德算法

计算形如 $\Large f(a, b, c, n) = \sum\limits_{i = 0}^{n}\lfloor \frac{ai + b}{c} \rfloor$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int P = 998244353;
int i2 = 499122177, i6 = 166374059;

struct data {
  data() { f = g = h = 0; }

  int f, g, h;
};  // 三个函数打包

data calc(int n, int a, int b, int c) {
  int ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;
  data d;
  if (a == 0) {  // 迭代到最底层
    d.f = bc * n1 % P;
    d.g = bc * n % P * n1 % P * i2 % P;
    d.h = bc * bc % P * n1 % P;
    return d;
  }
  if (a >= c || b >= c) {  // 取模
    d.f = n * n1 % P * i2 % P * ac % P + bc * n1 % P;
    d.g = ac * n % P * n1 % P * n21 % P * i6 % P + bc * n % P * n1 % P * i2 % P;
    d.h = ac * ac % P * n % P * n1 % P * n21 % P * i6 % P +
          bc * bc % P * n1 % P + ac * bc % P * n % P * n1 % P;
    d.f %= P, d.g %= P, d.h %= P;

    data e = calc(n, a % c, b % c, c);  // 迭代

    d.h += e.h + 2 * bc % P * e.f % P + 2 * ac % P * e.g % P;
    d.g += e.g, d.f += e.f;
    d.f %= P, d.g %= P, d.h %= P;
    return d;
  }
  data e = calc(m - 1, c, c - b - 1, a);
  d.f = n * m % P - e.f, d.f = (d.f % P + P) % P;
  d.g = m * n % P * n1 % P - e.h - e.f, d.g = (d.g * i2 % P + P) % P;
  d.h = n * m % P * (m + 1) % P - 2 * e.g - 2 * e.f - d.f;
  d.h = (d.h % P + P) % P;
  return d;
}

int T, n, a, b, c;

signed main() {
  scanf("%lld", &T);
  while (T--) {
    scanf("%lld%lld%lld%lld", &n, &a, &b, &c);
    data ans = calc(n, a, b, c);
    printf("%lld %lld %lld\n", ans.f, ans.h, ans.g);
  }
  return 0;
}

```
### 欧拉定理 & 费马小定理
**费马小定理** 若$p$为素数, $gcd(a, p) = 1$, 则 $a ^ {p - 1} \equiv 1 (mod$ $p)$
**欧拉定理** 若 $gcd(a, m) = 1$, 则 $ a ^ {\varphi(m)} \equiv 1 (mod$ $m)$ 
**扩展欧拉定理**
https://oi-wiki.org/math/number-theory/fermat/
### 中国剩余定理
$$
\begin{cases}
& x \equiv a_1 ({\rm mod }\quad m_1) \\
& x \equiv a_2 ({\rm mod }\quad m_2)  \\
& \vdots \\
& x \equiv a_n ({\rm mod})\quad m_n)
\end{cases}
$$
对于
1)$x = t1\cdot m_1 + a_1$
2)$x = t2 \cdot m_2 + a_2$
联立得
3)$t_1 \cdot m_1 + a_1 = t_2 \cdot m_2 + a_2$
移项
4)$t_1 \cdot m_1 + t_2 \cdot (-m_2) = a_2 - a_1$
至此可以直接 ${\rm exgcd}$求$t_1, t_2$
*******
若要找最小的$x$ $\rightarrow$ 要找到最小的 $t_1, t_2$使得等式成立(要求$x$最小)


```cpp
// find min x
void solve() {
    int n; cin >> n;
    int a = 0, b = 1; // x mod b = a
    auto merge = [&](int& a, int& b, int c, int d) -> void{
        if(a == -1 || b == -1)
            return;
        LL x, y;
        LL g = exgcd(b, d, x, y);
        if((c - a) % g != 0)
        {
            a = b = -1;
            return;
        }
        d /= g; // d'
        LL t = (c - a) / g % d; 
        LL t0 = x * t % d; // ka = ka'(mod m) -> a = a'(mod m / k) 其中 k | m
        if(t0 < 0) t0 += d;
        a = a + b * t0;
        b = b * d; // lcm
    };
    for(int i = 0; i < n; i ++)
    {
        int c, d; cin >> d >> c;
        merge(a, b, c, d); 
        if(a == -1 && b == -1)
        {
            cout << "-1\n";
            return;
        }
    }    
    cout << a << "\n";
}
// check x is exist
bool solve() {
    int n; cin >> n;
    map<int, vector<pair<int, int>>> mp;
    for(int i = 0; i < n; i ++)
    {
        int x, a; cin >> x >> a;
        for(int j = 2; j <= x / j; j ++)
        {
            if(x % j == 0)
            {
                int p = j, q = j;
                while(x % j == 0) x /= j, q *= j;
                mp[p].push_back({q, a % q});
            }
        }
        if(x > 1) mp[x].push_back({x, a % x});
    }
    for(auto& ite : mp)
    {
        auto v = ite.second;
        int t = max_element(v.begin(), v.end()) -> second;
        for(auto& val : v)
            if(t % val.first != val.second) return false;
    } 
    return true;
}
```
### 威尔逊定理
定理: 对于素数 $p$ 有 $(p - 1)!$ $\equiv -1$ $(mod$ $p)$

计算 $(n!)_p$ $\rightarrow$ $n!$ $mod$ $p$
```cpp
int factmod(int n, int p) {
  vector<int> f(p);
  f[0] = 1;
  for (int i = 1; i < p; i++) f[i] = f[i - 1] * i % p;
  int res = 1;
  while (n > 1) {
    if ((n / p) % 2) res = p - res;
    res = res * f[n % p] % p;
    n /= p;
  }
  return res;
}
```
#### 阶乘中素数的个数: 
$O(\log_p n)$时间内计算出 $n!$含有素数$p$的幂次为:
$\Large v_p(n!) = \sum\limits_{i = 1}^{\infty} {\lfloor \frac{n}{p^i} \rfloor}$
```cpp
int multiplicity_factorial(int n, int p) {
  int count = 0;
  do {
    n /= p;
    count += n;
  } while (n);
  return count;
}
```
另一种比较常用的是: $\Large v_p(n!) = \frac{n - S_p(n)}{p - 1}$ 其中 $S_p(n)$ 是 $n$的$p$进制表示下的各位数的和
特别的2的幂次是: $v_2(n!) = n - S_2(n)$
```cpp
int cal_s(int n, int p){
	int t = n;
	int res = 0;
	while(t)
	{
		res += t % p;
		t /= p;
	}
	return (n - res) / (p - 1);
}

```
#### Kummer定理
组合数对一个数取模的结果，往往构成分形结构,例如谢尔宾斯基三角形就可以通过组合数模 2 得到。
$\Large v_p\left[ \tbinom{m}{n} \right] = \frac{S_p(n) + S_p(m - n) - S_p(m)}{p - 1}$
特别的当 $p = 2$ 时
$\Large v_2\left[ \tbinom{m}{n} \right] = S_2(n) + S_2(m - n) - S_p(m)$

#### 威尔逊定理的推广
对于素数 $p$ 和正整数 $q$ 有 $(p^q!)_p = \pm 1 (mod$ $p^q)$
$$
(p^q!)_p=\begin{cases}
&1 \quad  if \ p = 2 \ and \  q \ge 3 \\
&-1 \quad otherwise.
\end{cases}
$$
#### 例题: 
给定$n$, 计算 $\Large \sum\limits_{k = 1}^{n}{\lfloor \frac{(3k + 6)! + 1}{3k + 7} - \lfloor \frac{(3k + 6)!}{3k + 7} \rfloor \rfloor}$
只需要看$(3k + 7)$是不是质数即可
### 升幂定理
#### 模为奇素数
$v_p(a^n - b^n) = v_p(a - b) + v_p(n)$
#### 模为2
- 如果$n$为奇数, 定理为等式
    $v_2(a^n - b^n) = v_2(a - b)$
- 如过$n$为偶数, 定理为等式
    $v_2(a^n - b^n) = v_2(a - b) + v_2(a + b) + v_2(n) - 1$
### Lucas
#### Lucas($p$为素数)
Lucas 定理用于求解大组合数取模的问题，其中模数必须为素数。
定义: 对于质数$p$:
$\Large \binom{n}{m} \ mod \ p = \binom{\lfloor \frac{n}{p} \rfloor}{ \lfloor \frac{m}{p} \rfloor } \cdot \binom{n \ mod \ p}{m \ mod \ p } \ mod \ p$ 
时间复杂度: $f(p) + g(n)log(n)$, $f(n)$为预处理组合数的时间, $g(n)$为单次处理组合数的时间
```cpp
long long Lucas(long long n, long long m, long long p) {
  if (m == 0) return 1;
  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```
#### exLucas($p$为任意)
时间复杂度: $O(p + T _\ \log p)$
```cpp
LL calc(LL n, LL x, LL P) {
  if (!n) return 1;
  LL s = 1;
  for (LL i = 1; i <= P; i++)
    if (i % x) s = s * i % P;
  s = Pow(s, n / P, P);
  for (LL i = n / P * P + 1; i <= n; i++)
    if (i % x) s = i % P * s % P;
  return s * calc(n / x, x, P) % P;
}

LL multilucas(LL m, LL n, LL x, LL P) {
  int cnt = 0;
  for (LL i = m; i; i /= x) cnt += i / x;
  for (LL i = n; i; i /= x) cnt -= i / x;
  for (LL i = m - n; i; i /= x) cnt -= i / x;
  return Pow(x, cnt, P) % P * calc(m, x, P) % P * inverse(calc(n, x, P), P) %
         P * inverse(calc(m - n, x, P), P) % P;
}

LL exlucas(LL m, LL n, LL P) {
  int cnt = 0;
  LL p[20], a[20];
  for (LL i = 2; i * i <= P; i++) {
    if (P % i == 0) {
      p[++cnt] = 1;
      while (P % i == 0) p[cnt] = p[cnt] * i, P /= i;
      a[cnt] = multilucas(m, n, i, p[cnt]);
    }
  }
  if (P > 1) p[++cnt] = P, a[cnt] = multilucas(m, n, P, P);
  return CRT(cnt, a, p);
}

```
## 组合数学
### 容斥
$$
\left| \bigcup \limits_{i = 1}^{n} S_i \right| = \sum \limits_{m = 1}^{n} (-1)^{m - 1} 
\sum \limits_{a_i < a_{i + 1} } \left| \bigcap \limits_{i = 1}^{m} S_{a_i} \right|
$$


## 杂项

### 异或相关



# 贪心

## 区间合并

给定 $n$ 个区间 $[l_i, r_i]$，要求合并所有有交集的区间。

注意如果在端点处相交，也算有交集。

输出合并完成后的区间个数。

```cpp
int n; cin >> n; 
vector<pair<int, int>> v(n);
for(auto&[l, r] : v) cin >> l >> r;
sort(v.begin(), v.end());
int cnt = 0;
int last = -2e9 + 10;
for(auto&[l, r] : v)
{
    if(l > last) last = r, cnt ++ ;
    last = max(last, r);
}
cout << cnt << "\n";
```

# 计算几何

```cpp

typedef double db;
const db eps = 1e-9;
inline int sign(db a) {
	return a < -eps ? -1 : a > eps; 
}
inline int cmp(db a, db b){
	return sign(a - b);
}
struct P{
	db x, y;
	P(){}
	P(db _x, db _y) : x(_x), y(_y){}
	P operator+ (P p) { return {x + p.x, y + p.y}; }
	P operator- (P p) { return {x - p.x, y - p.y}; }
	P operator* (db d) { return {x * d, y * d}; }
	P operator/ (db d) { return {x / d, y / d}; }
	
	bool operator< (P p) const{
		int c = cmp(x, p.x);
		if(c) return c == -1;
		return cmp(y, p.y) == -1;	
	}
	bool operator ==(P o) const{
		return cmp(x, o.x) == 0 && cmp(y, o.y) == 0;
	}
	db dot(P p) { return x * p.x + y * p.y; } // 求点积 
	db det(P p) { return x * p.y - y * p.x; } // 求叉积 
	db distTo(P p){ return (*this - p).abs(); } // 求两点之间的距离 
	double alpha() { return atan2(y, x); } // 求角度
	long double alphal() {return atan2l(y, x); }
	void read() { cin >> x >> y; }
	void wirte() { cout << "(" << x << "," << y << ")" << "\n"; }
	db abs() { return sqrt(abs2()); } 
	db abs2() { return x * x + y * y; }
	P rot90() { return P(-y, x); }
	P unit() { return *this/abs(); }
	int quad() const {} // to do
	P rot(db an) { return {x * cos(an) - y * sin(an), x * sin(an) + y * cos(an)}; }
	
};
#define cross(p1, p2, p3) ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y))
// p1p1 x p1p3
#define crossOp(p1, p2, p3) sign(cross(p1, p2, p3))

// 直线p1p2 q1q2 是否恰有一个交点 
bool chkLL (P p1, P p2, P q1, P q2){ // 判断两条直线是否是相交关系 
	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return sign(a1 + a2) != 0;
}

P isLL(P p1, P p2, P q1, P q2){
	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}
// 判断区间 [l1, r1], [l2, r2] 是否相交
bool intersect(db l1, db r1, db l2, db r2){
	if (l1 > r1) swap(l1, r1); if(l2 > r2) swap(l2, r2);
	return !(cmp(r1, l2) == -1 || cmp(r2, l1) == -1); 
}
// 线段相交 
bool isSS(P p1, P p2, P q1, P q2) {
	return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)
	&& crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <= 0;
	
}
// 线段严格相交
bool isSS_strict(P p1, P p2, P q1, P q2){
	return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) < 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;	
}
// 看m在不在[a,b]之间 
bool isMiddle(db a, db m, db b){
	return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);
}
// 看点m在不在 点 a, b之间 
bool isMiddle(P a, P m, P b){
	return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);	
}
// 点q是否在线段 p1p2 上 
bool onSeg(P p1, P p2, P q){
	return crossOp(p1, p2, q) == 0 && isMiddle(p1, q, p2);	
}
bool onSeg_strict(P p1, P p2, P q){
	return crossOp(p1, p2, q) == 0 && sign((q-p1).dot(p1-p2)) * sign((q - p2).dot(p1 - p2)) < 0;
}
// 求 q 到 直线p1p2的投影 
P proj( P p1, P p2, P q){
	P dir = p2 - p1;
	return p1 + dir * (dir.dot(q - p1) / dir.abs2());
}
// 求 以 直线 p1p2为轴的反射 
P reflect(P p1, P p2, P q){
	return proj(p1, p2, q) * 2 - q; 	
}
// 求 q 到线段 p1p2的最小距离 
db nearest(P p1, P p2, P q){
	if(p1 == p2) return p1.distTo(q);
	P h = proj(p1, p2, q);
	if(isMiddle(p1, h, p2))
		return q.distTo(h);
	return min(p1.distTo(q), p2.distTo(q)); 
}
// 求线段 p1p2 q1q2 的距离 
db disSS(P p1, P p2, P q1, P q2){
	if(isSS(p1, p2, q1, q2)) return 0;
	return min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));
}
```

# 常用函数

## python 头文件

```python
import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import operator
import threading
import bisect
BUFSIZE = 4096
Inf = float('inf')
eps = 1e-6
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")
def I():
   return input()
def II():
   return int(input())
def MI():
   return map(int, input().split())
def LI():
   return list(input().split())
def LII():
   return list(map(int, input().split()))
def GMI():
   return map(lambda x: int(x) - 1, input().split())
def LGMI():
   return list(map(lambda x: int(x) - 1, input().split()))

```
## xor相关

给一个序列中 有多少异或和为 x 比如 输入 
3
1 2 3
0
output: 1
```cpp

#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

#define int LL

void solve(){
	int n; cin >> n;
	vector<int> v(n); for(int& i : v) cin >> i;
	int x; cin >> x;
	unordered_map<int, int> mp;
	int t = 0, res = 0;
	mp[0] = 1;
	for(int& i : v)
	{
		t ^= i;
		res += mp[t];
		mp[t] ++ ;
	}
	cout << res << "\n";
}
signed main(){

    ios::sync_with_stdio(false);
    std::cin.tie(0);
	int T = 1;
    while(T--) solve();
    return 0;
}

```
问题描述：给出一段区间 $[L,R]$（连续区间），假设 区间长度为 $len$，那么一共有 $len*(len-1)/2$个 pair，问所有pair的异或和为多少
```cpp
// [1, 3] 1 ^ 2 = 3, 1 ^ 3 = 2, 2 ^ 3 = 1 -> total = 3 + 2 + 1 = 6
//  l, r <= 1e6
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

#define int LL

void solve(){
	int l, r; cin >> l >> r; 
	int res = 0;
	for(int k = 0; k < 31; k ++)
	{
		int z = 0, o = 0;
		for(int i = l; i <= r; i ++)
		{
			int x = i >> k & 1;
			if(x) 
				res += (1 << k) * z, o++ ; // 对于所有当前位等于 0 当前的这位1是有效的
			else
				res += (1 << k) * o, z++ ;
		}
	}
	cout << res << "\n";
}
signed main(){

    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int T = 1;
    while(T--) solve();
    return 0;
}

```

```cpp
// 和 02.cpp 的要求一样 只不过现在 L, R <= 1e18
// 假设当前n个数字中 第k位有x个1 那么 总体的贡献为 (n - x) * (1 << k) * x // 简单的排列组合
// 现在问题变成要求第k位有几个1了
// f(x, k) -> 1 ~ k 有多少个1 根据 周期 第一位的周期为 2 第二位的周期为 4 第三位的周期为8
// ans = \sum_{i = 0}^{i = 63} * (f(r, i) - f(l - 1, i));
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

#define int LL

void solve(){
	int L, R; cin >> L >> R;
	L -- ;
	int n = R - L;
	vector<int> l(64), r(64);
	int p = 1;
	for(int i = 0; i < 64; i ++)
	{
		int k = (L + 1) / (p * 2), m = (L + 1) % (p * 2);
		l[i] = k * p + ((m - p) >= 0 ? m - p : 0);
		p <<= 1;
		if(p > (L + 1)) break;
	}
	p = 1;
	for(int i = 0; i < 64; i ++)
	{
		int k = (R + 1) / (p * 2), m = (R + 1) % (p * 2);
		r[i] = k * p + ((m - p) >= 0 ? m - p : 0);
		p <<= 1;
		if(p > (R + 1)) break;
	}
	int res = 0;
	for(int k = 0; k < 32; k ++)
	{
		int d = r[k]- l[k];
		res += (1 << k) * (d) * (n - d); 
	}
	cout << res << "\n";
}
signed main(){

    ios::sync_with_stdio(false);
    std::cin.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}


```


```cpp


#include <bits/stdc++.h>
 
typedef long long LL;
#define int LL

using namespace std;

const int mod = 1e9 + 7;
// 求所有连续子数组中 两两配对的异或值
signed main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n;
    vector<int> a(n); for(int& i : a) cin >> i;
    LL res = 0;
    for(int k = 0; k < 30; k ++)
    {
    	vector<int> l(n), r(n);
    	for(int i = 0; i < n; i ++)
    		r[i] = (a[i] >> k) & 1, l[i] = 1 - r[i];
    	vector<LL> s0(n + 1), s1(n + 1);
    	for(int i = 0; i < n; i ++)
    		if(r[i])
    		{
    			s1[i + 1] = s1[i] + i + 1;
    			s0[i + 1] = s0[i];	
    		}
    		else
    		{
    			s0[i + 1] = s0[i] + i + 1;
    			s1[i + 1] = s1[i];
    		}
    	for(int i = n - 1; i >= 0; i --)
    	{
    		if(r[i])
    			res += (n - i) * (1 << k) % mod * s0[i] % mod;
    		else
    			res += (n - i) * (1 << k) % mod * s1[i] % mod;
    	}
    	res %= mod;
    }
    cout << res << "\n";
    
    return 0;
}


```


## bitset

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    bitset<100010> s;
    int pos = 1;
    s.reset(); // set all 0
    s.reset(pos); // set pos to 0
    s.set(); // set all 1
    s.set(pos); // set pot to 1
    s.set(pos, false); // set pow false/true 
    s.count(); // return count 1
    s.size(); // return size
    s.any(); // if 1 in s return true
    s.none(); // if all 0 return true
    s.all(); // if all 1 return true
    s.flip(); // ^ bitset<N> s; s.set();
    s.flip(pos); // filp pos
    s.to_string(); // to_string
    s.to_ullong(); // return unsigned long long
    s.to_ulong(); // return unsigned long
    s._Find_first(); // return first idx 1 if 1 in s else return size of s
    s._Find_next(); // return >= pos first idx 1 if 1 is s[pos:] else return size of s
    return 0;
}
```

## algorithm

```cpp

```
## SortedList_py
```python
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """Initialize sorted list instance."""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] 
        self._list_lens = [len(_list) for _list in _
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """Build a fenwick tree instance."""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """Update `fen_tree[index] += value`."""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """Return `sum(_fen_tree[:end])`."""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """Return a pair of (the largest `idx` such 
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_le
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_l
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """Delete value at the given `(pos, idx)`.""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """Return an index pair that corresponds to 
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """Return an index pair that corresponds to 
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """Add `value` to sorted list."""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:]
                _list_lens.insert(pos + 1, len(_list
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """Remove `value` from sorted list if it is 
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value
                self._delete(pos, idx - 1)

    def remove(self, value):
        """Remove `value` from sorted list; `value` 
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.for

    def pop(self, index=-1):
        """Remove and return value at `index` in sor
        pos, idx = self._fen_findkth(self._len + ind
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """Return the first index to insert `value` 
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """Return the last index to insert `value` i
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """Return number of occurrences of `value` i
        return self.bisect_right(value) - self.bisec

    def __len__(self):
        """Return the size of the sorted list."""
        return self._len

    def __getitem__(self, index):
        """Lookup value at `index` in sorted list.""
        pos, idx = self._fen_findkth(self._len + ind
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """Remove value at `index` from sorted list.
        pos, idx = self._fen_findkth(self._len + ind
        self._delete(pos, idx)

    def __contains__(self, value):
        """Return true if `value` is an element of t
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists
        return False

    def __iter__(self):
        """Return an iterator over the sorted list."
        return (value for _list in self._lists for v

    def __reversed__(self):
        """Return a reverse iterator over the sorted
        return (value for _list in reversed(self._li

    def __repr__(self):
        """Return string representation of sorted li
        return 'SortedList({0})'.format(list(self))
```

